{"version":3,"sources":["App.js","file/index.js","serviceWorker.js","index.js"],"names":["timer","needLongerTime","App","text","useRef","resume","useState","styleText","domStyleText","setStyletext","resumeText","setResumeText","writeChar","nodeName","char","a","Promise","resolve","setTimeout","temp","Prism","highlight","languages","css","current","scrollTop","scrollHeight","content","showdown","Converter","makeHtml","includes","writeTo","index","slice","length","useEffect","className","ref","dangerouslySetInnerHTML","__html","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"oKAMIA,E,sGACFC,G,MAAiB,CAAC,SAAK,SAAK,WAuFfC,MArFf,WACE,IAAMC,EAAOC,iBAAO,MACdC,EAASD,iBAAO,MAFT,EAGqBE,mBAAS,CACzCC,UAAW,GACXC,aAAc,KALH,mBAGND,EAHM,KAGKE,EAHL,OAOuBH,mBAAS,CAC3CC,UAAW,GACXC,aAAc,KATH,mBAONE,EAPM,KAOMC,EAPN,KAYPC,EAAS,uCAAG,WAAOC,EAAUC,GAAjB,SAAAC,EAAA,+EAA0B,IAAIC,SAAQ,SAAAC,GACtDC,YAAW,WACQ,iBAAbL,GACFJ,GAAa,SAAAN,GAAS,IACZI,EAA2BJ,EAA3BI,UACJY,GAD+BhB,EAAjBK,aACPD,EAAYO,GAGvB,MAAO,CACLP,UAAWY,EACXX,aAJQM,EAAcM,IAAMC,UAAUF,EAAKC,IAAME,UAAUC,IAAI,WAQnEpB,EAAKqB,QAAQC,UAAYtB,EAAKqB,QAAQE,cAChB,mBAAbb,IACTF,GAAc,SAAAR,GAAS,IACbI,EAAcJ,EAAdI,UACJY,EAAOZ,EAAYO,EACnBa,EAAU,IAAIC,IAASC,UAG3B,OADAF,EAAUA,EAAQG,SAASX,GACpB,CACLZ,UAAWA,EAAYO,EACvBN,aAAcmB,MAIlBtB,EAAOmB,QAAQC,UAAYpB,EAAOmB,QAAQE,cAI1C1B,EADEC,EAAe8B,SAASjB,GAClB,IAEA,GAGVG,MACCjB,OAtCa,2CAAH,wDAyCTgC,EAAO,uCACX,WAAOnB,EAAUoB,EAAO9B,GAAxB,eAAAY,EAAA,yDACMD,EAAOX,EAAK+B,MAAMD,IAASA,KAE3BA,EAAQ9B,EAAKgC,QAHnB,iEAKQvB,EAAUC,EAAUC,GAL5B,uBAMQkB,EAAQnB,EAAUoB,EAAO9B,GANjC,2CADW,0DAiBb,OAPAiC,qBAAU,WACR,sBAAC,sBAAArB,EAAA,sEACOiB,EAAQ,eAAgB,EC1EtB,w+EDyET,uBAEOA,EAAQ,iBAAkB,EC2EhB,qcD7EjB,uBAGOA,EAAQ,eAAgB,EC6BtB,0/BDhCT,0CAAD,KAKC,IAED,oCACE,yBAAKK,UAAU,eAAeC,IAAKnC,GACjC,yBAAKoC,wBAAyB,CAAEC,OAAQjC,EAAUC,gBAClD,2BAAO+B,wBAAyB,CAAEC,OAAQjC,EAAUA,cAEtD,yBAAK8B,UAAU,iBACbC,IAAKjC,EACLkC,wBAAyB,CAAEC,OAAQ9B,EAAWF,kBE3ElCiC,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2DCZNC,IAASC,OAAO,kBAAC,EAAD,MAASC,SAASC,eAAe,SD6H3C,kBAAmBC,WACrBA,UAAUC,cAAcC,MACrBC,MAAK,SAAAC,GACJA,EAAaC,gBAEdC,OAAM,SAAAC,GACLC,QAAQD,MAAMA,EAAME,a","file":"static/js/main.64969c04.chunk.js","sourcesContent":["import React, { useState, useEffect, useRef } from 'react';\nimport Prism from 'prismjs'\nimport showdown from 'showdown'\nimport { a, b, resumeTxt } from './file'\nimport './App.css';\n\nlet timer,\n  needLongerTime = ['？', '，', '！']\n\nfunction App() {\n  const text = useRef(null)\n  const resume = useRef(null)\n  const [styleText, setStyletext] = useState({\n    styleText: '',\n    domStyleText: ''\n  })\n  const [resumeText, setResumeText] = useState({\n    styleText: '',\n    domStyleText: ''\n  })\n\n  const writeChar = async (nodeName, char) => new Promise(resolve => {\n    setTimeout(() => {\n      if (nodeName === 'page-wrapper') {\n        setStyletext(text => {\n          const { styleText,domStyleText } = text\n          let temp = styleText + char\n          let html =char = '*' ?  Prism.highlight(temp,Prism.languages.css,'css') : temp \n\n          return {\n            styleText: temp,\n            domStyleText: html\n          }\n        })\n\n        text.current.scrollTop = text.current.scrollHeight\n      } else if (nodeName === 'resume-wrapper') {\n        setResumeText(text => {\n          const { styleText } = text\n          let temp = styleText + char\n          let content = new showdown.Converter()\n\n          content = content.makeHtml(temp)\n          return {\n            styleText: styleText + char,\n            domStyleText: content\n          }\n        })\n\n        resume.current.scrollTop = resume.current.scrollHeight\n      }\n\n      if (needLongerTime.includes(char)) {\n        timer = 200\n      } else {\n        timer = 15\n      }\n\n      resolve()\n    }, timer)\n  })\n\n  const writeTo =\n    async (nodeName, index, text) => {\n      let char = text.slice(index, ++index)\n\n      if (index > text.length) return\n\n      await writeChar(nodeName, char)\n      await writeTo(nodeName, index, text)\n    }\n\n  useEffect(() => {\n    (async () => {\n      await writeTo('page-wrapper', 0, a)\n      await writeTo('resume-wrapper', 0, resumeTxt)\n      await writeTo('page-wrapper', 0, b)\n    })()\n  }, [])\n  return (\n    <>\n      <div className='page-wrapper' ref={text}>\n        <div dangerouslySetInnerHTML={{ __html: styleText.domStyleText }} ></div>\n        <style dangerouslySetInnerHTML={{ __html: styleText.styleText }}></style>\n      </div>\n      <div className='resume-wrapper'\n        ref={resume}\n        dangerouslySetInnerHTML={{ __html: resumeText.domStyleText }}\n      >\n      </div>\n    </>\n  );\n}\n\nexport default App;\n","export const a = \r\n`/*\r\n*创意来自 strml.net\r\n*\r\n* 大家好，我是Gio，\r\n*\r\n* 这张页面好无聊啊！我们加一点小东西如何？\r\n* 首先，先来添加一下全局的动画效果！\r\n*/ \r\n\r\n*{\r\n  -webkit-transition: all .8s;\r\n  transition: all .8s;\r\n} \r\n\r\n/* 啊？没效果么？背景变一下颜色可好？*/\r\n\r\nhtml {\r\n  /* \r\n  3，\r\n  2，\r\n  1 */\r\n  background: rgb(56,0,60); \r\n}\r\n.token.comment{ \r\n    color: white \r\n}\r\n\r\n\r\n/* 哈哈！厉害吧！？\r\n\r\n* 抱歉抱歉，你的眼睛是不是要瞎了？那字体也变一下呗？\r\n\r\n*/\r\n\r\n.page-wrapper{\r\n  margin-top:48px;\r\n  color: rgb(222,222,222); \r\n  overflow: auto;\r\n  background: rgb(48, 48, 48);\r\n  border: 1px solid #ccc;\r\n  max-height: 50%;\r\n  width: 35%;\r\n  font-size: 14px;\r\n  font-family: monospace;\r\n  padding: 10px 10px 20px;\r\n  box-shadow: -4px 4px 2px 0 rgba(0,0,0,0.3);\r\n  white-space: pre-wrap;\r\n  outline: 0;\r\n}\r\n\r\n\r\n\r\n/* \r\n* ！\r\n* yoyoyoyo，怎样？抱歉让你的眼睛损伤啦～ \r\n* 接下来我们玩一点高端的「代码高亮」！\r\n\r\n*/\r\n\r\n\r\n.token.comment{ color: #857F6B; font-style: italic; }\r\n.token.selector{ color: #E69F0F; }\r\n.token.property{ color: #64D5EA; }\r\n.token.punctuation{ color: #64D5EA; }\r\n.token.function{ color: #BE84F2; }\r\n\r\n\r\n/*\r\n\r\n* 哈哈，是不是非常不错？\r\n* 嗯，我们准备写一点其他的东西，把这个东西往右移动一下！\r\n* 3，\r\n* 2，\r\n* 1\r\n*/\r\n\r\n.page-wrapper {\r\n  -webkit-transform: translateX(150%);\r\n  transform:translateX(150%);\r\n}\r\n\r\n/*\r\n* 接下来我们写一份简历好不好？\r\n* 首先我们先准备一个打字框！\r\n*/\r\n\r\n.resume-wrapper{\r\n  position:fixed;\r\n  top:0;\r\n  padding: .5em;  margin: .5em;\r\n  background: white; \r\n  color: #222;\r\n  margin-top:48px;\r\n  width: 40vw; height:50%; \r\n  border: 1px solid;\r\n  overflow: auto;\r\n  color: rgb(222,222,222); \r\n  background: rgb(48, 48, 48);\r\n}\r\n\r\n/*\r\n* 好，我们立马开写！\r\n*/`\r\n\r\nexport const b = \r\n`.resume-wrapper{\r\n  height:50%;\r\n}\r\n\r\n/* 还行吗？是不是很酷？\r\n\r\n那么我们再来一点3D效果！\r\n\r\n*/\r\nbody {\r\n  -webkit-perspective: 1000px;\r\n  perspective:1000px;\r\n  width: 100%;\r\n  height: 100%;\r\n  overflow: hidden;\r\n}\r\n\r\n/*  诶？没有效果吗？别急 */\r\n.resume-wrapper {\r\n  -webkit-transform: rotateX(0deg) rotateY(190deg) ;\r\n}\r\n\r\n/*  是不是很帅？？？ */\r\n.resume-wrapper {\r\n  box-shadow: 0px 0px 0px #888888;\r\n  -webkit-transform: rotateY(10deg);\r\n  -webkit-transform-origin: left;\r\n  transform:rotateY(10deg);\r\n  -webkit-transform-origin:rotateY(10deg);\r\n  max\r\n}\r\n\r\n.page-wrapper {\r\n  box-shadow: 0px 0px 0px #888888;\r\n  -webkit-transform: translateX(150%) rotateY(-10deg);\r\n  -webkit-transform-origin: right;\r\n  transform:translateX(150%) rotateY(-10deg);\r\n  transform-origin: right;\r\n}\r\n\r\n/* \r\n本次代码直播结束啦！\r\n*/`\r\n\r\nexport const resumeTxt = \r\n`Gio\r\n=============\r\n- Web前端开发\r\n- Node.js开发\r\n\r\n技能\r\n=============\r\n- node.js \r\n- React技术栈\r\n- Ant Design\r\n- Echarts\r\n\r\n工作经历\r\n=============\r\n- 上海同济学士信息系统有限公司:Web前端开发\r\n\r\n链接\r\n=============\r\n- [本项目的源代码](https://github.com/qq1193078960/resume-gio)`\r\n\r\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}